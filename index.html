<!doctype html>
<!--
マップの開き方（ローカル）
cd /path/to/web
python -m http.server 8000
http://localhost:8000/
-->
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>避難経路マップ（高島市周辺）</title>
  <link rel="icon" href="data:,">

  <!-- OpenLayers -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@9.2.4/ol.css">
  <script src="https://cdn.jsdelivr.net/npm/ol@9.2.4/dist/ol.js"></script>

  <!-- FlatGeobuf (local) -->
  <script src="./flatgeobuf-geojson.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Meiryo", sans-serif; }
    #app { display: grid; grid-template-columns: 420px 1fr; height: 100%; }
    #panel { border-right: 1px solid #e5e7eb; padding: 14px 14px 10px; overflow: auto; }
    #map { width: 100%; height: 100%; }
    h1 { font-size: 16px; margin: 0 0 10px; }
    h2 { font-size: 13px; margin: 14px 0 6px; }
    .muted { color: #555; font-size: 12px; }
    .box { background: #f8fafc; border: 1px solid #e5e7eb; border-radius: 10px; padding: 10px; }
    .controls { display: grid; gap: 10px; }
    .row { display: grid; grid-template-columns: 120px 1fr; gap: 8px; align-items: center; }
    select, input[type="range"], button { width: 100%; }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #d1d5db; background: #fff; cursor: pointer; }
    button:hover { background: #f3f4f6; }
    pre { margin: 0; white-space: pre-wrap; word-break: break-word; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; }

    details > summary { cursor: pointer; font-weight: 700; }

    .note { background:#fff; border:1px solid #e5e7eb; border-radius:10px; padding:10px; }
    .warn { background: #fff7ed; border: 1px solid #fed7aa; border-radius: 10px; padding: 10px; }
    .warn b { color: #9a3412; }

    /* Popup */
    .ol-popup {
      position: absolute;
      background: white;
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid #e5e7eb;
      min-width: 220px;
      max-width: 340px;
      font-size: 12px;
      line-height: 1.5;
    }
    .ol-popup:after, .ol-popup:before {
      top: 100%;
      border: solid transparent;
      content: " ";
      height: 0;
      width: 0;
      position: absolute;
      pointer-events: none;
    }
    .ol-popup:after {
      border-top-color: white;
      border-width: 10px;
      left: 28px;
      margin-left: -10px;
    }
    .ol-popup:before {
      border-top-color: #e5e7eb;
      border-width: 11px;
      left: 28px;
      margin-left: -11px;
    }
    .popup-head { display:flex; align-items:center; justify-content:space-between; gap:10px; }
    .popup-title { font-weight: 800; }
    .popup-close {
      border: 1px solid #d1d5db;
      background:#fff;
      border-radius:8px;
      padding:2px 8px;
      cursor:pointer;
      font-size:12px;
    }
    .popup-close:hover { background:#f3f4f6; }
	
	/* 経路の基準：box無しで“付随”っぽく */
    .details-compact {
      margin-top: 6px;
    }
    .details-compact > summary {
      cursor: pointer;
      list-style: none;
      font-weight: 600;
    }
    .details-compact[open] {
      margin-bottom: 6px;
    }
    .details-compact .row label {
      white-space: nowrap;   /* 1行表示 */
    }
  </style>
</head>

<body>
<div id="app">
  <div id="panel">
    <h1>避難経路マップ（高島市周辺）</h1>

    <!-- 1) タイトル直下：短い概要＋免責 -->
    <div class="note" id="introShort">
      <div class="muted" style="white-space:pre-wrap; line-height:1.5;">
本マップは、高島市周辺において、できるだけ安全に、かつ早く避難できる経路を示すことを目的とした参考マップです。

・本マップは避難時の安全を保証するものではありません。実際にご自身で経路を確認し、危険箇所の有無をご確認ください。
・データの都合により、未反映の道路や位置ずれ等の不整合が含まれる場合があります。
・マップの読み込み及び経路表示に時間がかかることがあります。
・表示される避難時間は代表的な年齢を使った目安の時間です。あくまで参考情報としてご覧ください。
      </div>
    </div>

    <!-- 2) 使い方（デフォルト閉） -->
    <h2>使い方</h2>
    <div class="box">
      <details>
        <summary>クリックして開く</summary>
        <div class="muted" style="white-space:pre-wrap; line-height:1.5; margin-top:8px;">
1. 年齢 と 期待安全度 を選びます
2. 地図上をダブルクリックします（最寄りの道路結節点を出発点として計算します）
3. 表示された経路と避難所名・所要時間を確認してください
4．破線で表示された道路（危険区間）をクリックすると、その区間のリスク情報（浸水・転落）を確認できます
        </div>
      </details>
    </div>

    <!-- 3) 表示の見方（経路分類・色・定義） -->
    <h2>表示の見方</h2>
    <div class="box">
      <details>
        <summary>クリックして開く</summary>
        <div class="muted" style="white-space:pre-wrap; line-height:1.5; margin-top:8px;">
【経路の分類】
A：同じ自治体内の避難所への経路（推奨）
B：自治体境界を無視した場合の避難所への経路（市外を含む場合があります）
CA：転落リスクのみを回避し、同自治体内の避難所へ到達する経路
CB：転落リスクのみを回避し、すべての避難所へ到達する経路
A0/B0：期待安全度=0.0（リスクを無視）での経路（最も早く避難できる経路）

【マーカー】
黒丸：指定地点（クリック地点）
S：出発点
A/B/CA/CB：目的地（避難所）

【危険区間（赤/橙/紫）】
経路上の危険区間をクリックすると、浸水・転落のリスク情報を表示します。
※ここで示す「リスク」は研究上の指標であり、現実の安全を保証するものではありません。
        </div>
      </details>
    </div>

    <!-- 4) 設定 -->
    <h2>設定</h2>
    <div class="box controls">
      <div class="row">
        <div>年齢</div>
        <select id="ageSelect"></select>
      </div>

      <div class="row">
        <div>期待安全度</div>
        <div>
          <input id="thrRange" type="range" min="0" max="1" step="0.1" value="0.6">
          <div class="muted">現在：<span id="thrLabel">0.6</span></div>
        </div>
      </div>

      <div class="row">
        <div>リセット</div>
        <button id="clearBtn">クリア</button>
      </div>
    </div>

    <!-- 5) オプション -->
    <details id="optDetails" class="details-compact">
	  <summary>オプション</summary>

      <div class="row" style="margin-top:8px;">
          <label><input type="checkbox" id="optComposite" checked> 複合リスク回避経路（浸水＆転落）</label>
      </div>
      <div class="row" style="margin-top:4px;">
          <label><input type="checkbox" id="optRfallOnly"> 転落リスク回避経路（転落のみ）</label>
      </div>

      <div class="muted" style="margin-top:8px; line-height:1.5;">
「転落リスク回避」を選ぶと、浸水は考慮せず、転落リスクがある道路を避ける経路を優先して表示します。
      </div>
    </details>

    <!-- 6) 経路の情報（旧：結果） -->
    <h2>経路の案内</h2>
    <div class="box">
      <pre id="result">地図をダブルクリックしてください。</pre>
    </div>

    <!-- 7) ステータス（ユーザー向けに整理） -->
    <h2>状態</h2>
    <div class="box">
      <pre id="status">データ読み込み中…</pre>
    </div>

    <!-- 8) 詳細説明欄（長文はこちらへ） -->
    <h2>補足と注意事項</h2>
    <div class="box">
      <details>
        <summary>クリックして開く</summary>
        <div class="muted" style="white-space:pre-wrap; line-height:1.5; margin-top:8px;">
【クリック地点と出発点の誤差】
経路計算の出発点は、ダブルクリック地点そのものではなく、最も近い道路結節点（交差点など）等です。そのため、クリック地点と出発点が数十mずれる場合があります。

【期待安全度】
期待安全度は、避難経路に求める最低限の安全さを意味する指標です。値を高くすると危険区間を避けやすくなります。
例：
期待安全度＝1.0→研究上、危険が存在しない道路のみを用いた経路を表示します。
期待安全度＝0.0→危険の有無にかかわらず、すべての道路を用いた経路を表示します。迂回行動をしない最も早く避難ができる経路です。


【表示の順番】
表示される経路はすべて、選択した条件（年齢・期待安全度・モード）のもとで「最短時間」となる経路です。
ただし、条件を満たす経路が見つからない場合は、次の優先順位で「代替経路」を表示します。

1．A / B（条件を満たす経路）
　期待安全度の条件を満たし、避難所まで到達できる経路を表示します。
・A：自治体内の避難所（出発点と同じ自治体の避難所）への最短経路
・B：自治体外を含む避難所（出発点と異なる自治体の避難所）への最短経路
　※A と B は同じ経路になる場合があり、その場合は 1 本だけ表示します。

2．CA / CB（危険区間をできるだけ避ける代替経路）
　A / B が到達不能（期待安全度の条件を満たす道路だけでは避難所へ行けない）な場合、
　浸水が始まる前の早期避難を想定し、転落リスクのみをできるだけ回避した代替経路（CA/CB）を表示します。
・CA：自治体内の避難所への代替経路
・CB：自治体外を含む避難所への代替経路
　※CA と CB も同一経路になる場合は 1 本だけ表示します。

3．A0 / B0（安全度条件を無視した経路：最短時間）
　CA / CB でも到達不能な場合、最後の手段として、
　期待安全度の条件を無視して（危険の有無に関係なく道路を使い）避難所へ向かう最短経路を表示します。
・A0：自治体内の避難所への最短経路
・B0：自治体外を含む避難所への最短経路　
　※A0 と B0 が同一経路の場合は 1 本のみ表示します。

補足：期待安全度の値や出発点周辺の地形・道路状況によっては、危険区間を完全に避けられない場合があります。
その場合、上記の優先順位に従って「到達可能な経路」が表示されます。

【最終更新日】
2026/1/25
        </div>
      </details>
    </div>

    <!-- 9) 連絡先（後で追記枠） -->
    <h2>連絡先・フィードバック</h2>
    <div class="box">
      <div class="muted" style="white-space:pre-wrap; line-height:1.5;">
不具合報告・改善提案は GitHub の Issues でご連絡ください。
https://github.com/nishimoto-KU/takashima_evac_route_demo/issues

作成者：<br>京都大学大学院 工学研究科 都市社会工学専攻<br> 修士課程（2025年度修了）   西本　大輔
      </div>
    </div>
	
	<!-- ここから下は「別ブロック」 -->
    <div class="muted" style="margin-top:8px; font-size:0.85em;">
    Map data<br>
	© OpenStreetMap contributors / © OpenLayers contributors
    </div>
  </div>

  <div id="mapWrap" style="position:relative;">
    <div id="map"></div>

    <!-- Popup -->
    <div id="popup" class="ol-popup" style="display:none;">
      <div class="popup-head">
        <div id="popup-title" class="popup-title">リスク情報</div>
        <button id="popup-close" class="popup-close" type="button">閉じる</button>
      </div>
      <div id="popup-content" style="margin-top:8px;"></div>
    </div>
  </div>
</div>

<script>
(() => {
  const statusEl = document.getElementById("status");
  const resultEl = document.getElementById("result");
  const ageSelect = document.getElementById("ageSelect");
  const thrRange = document.getElementById("thrRange");
  const thrLabel = document.getElementById("thrLabel");
  const clearBtn = document.getElementById("clearBtn");

  const popupEl = document.getElementById("popup");
  const popupTitleEl = document.getElementById("popup-title");
  const popupContentEl = document.getElementById("popup-content");
  const popupCloseBtn = document.getElementById("popup-close");

  // --- 状態表示（クリック前は「表示条件」を出さない） ---
  let uiStatusMode = "loading"; // "loading" | "ready" | "cond"
  let uiCondText   = "";        // mode==="cond" のときだけ表示
  
  
  function getAgeLabel(){
    return ageSelect?.options?.[ageSelect.selectedIndex]?.textContent ?? `${ageSelect.value}歳`;
  }

  
  function renderStatus(){
    if (uiStatusMode === "loading") {
      statusEl.textContent = "データ読み込み中…";
    } else if (uiStatusMode === "ready") {
      statusEl.textContent = "準備完了：地図をダブルクリックしてください";
    } else { // "cond"
      statusEl.textContent = uiCondText || "準備完了：地図をダブルクリックしてください";
    }
  }
  
  function setStatusLoading(){
    uiStatusMode = "loading";
    renderStatus();
  }
  function setStatusReady(){
    uiStatusMode = "ready";
    renderStatus();
  }
  function setStatusCond(age, thr){
    uiStatusMode = "cond";
    uiCondText = `表示条件：年齢 ${age}歳 / 期待安全度 ${Number(thr).toFixed(1)}`;
    renderStatus();
  }
  
  // 初期表示
  setStatusLoading();
  
  // ===== 互換ラッパー（既存コードが setStateLine / setCondLine を呼んでも壊れないようにする）=====
  // 旧: setStateLine("データ読み込み中…（〜）") など → 新: ロード中/完了を自動判定
  function setStateLine(s){
    const t = String(s || "");
    // 何をロード中かは出さない要求なので、内容は丸めて状態だけにする
    if (t.includes("読み込み中")) {
      setStatusLoading();
      return;
    }
    // 旧コードで「準備完了：〜」などを出していた場合
    if (t.includes("ダブルクリック")) {
      setStatusReady();
      return;
    }
    // それ以外は「表示条件」扱いにする（必要ならここで文言を調整可能）
    uiStatusMode = "cond";
    uiCondText = t;
    renderStatus();
  }
  
  // 旧: setCondLine(age, thr, modeLabel) → 新: 表示条件（年齢/期待安全度）だけ表示
  function setCondLine(age, thr, modeLabel){
    setStatusCond(age, thr);
  }
  

  if (typeof window.ol === "undefined") {
    setStateLine("エラー：地図ライブラリ（OpenLayers）の読み込みに失敗しました。");
    return;
  }

  // ---------- Colors / styles ----------
  const ROUTE_STYLE = {
    "A":  { color: "rgba(0, 90, 200, 0.85)", width: 7 }, // muni (推奨)
    "B":  { color: "rgba(30, 30, 30, 0.70)", width: 6 }, // global
    "CA": { color: "rgba(0, 140, 60, 0.85)", width: 7 }, // muni rfall avoid
    "CB": { color: "rgba(80, 180, 120, 0.80)", width: 6 }, // global rfall avoid
    "A0": { color: "rgba(0, 90, 200, 0.55)", width: 6 },
    "B0": { color: "rgba(30, 30, 30, 0.45)", width: 5 },
  };

  const RISK_COLOR = {
    "FLOOD": "rgba(220,0,0,0.30)",
    "FALL":  "rgba(255,140,0,0.30)",
    "BOTH":  "rgba(150,0,200,0.30)"
  };

  const DASH_FINE = [2, 4];
  const TOL_JOIN = 5e-5;

  // ---------- Stores ----------
  let lonArr=null, latArr=null, nodeIdArr=null, muniArr=null, isShelterArr=null, nNodes=0;
  const nodeID2Vid = new Map();

  let grid=null, gridMinLon=0, gridMinLat=0, gridCell=0.01;

  const edgeSegsById = new Map();
  const edgePartIndex = new Map();
  const routeResultCache = new Map();
  const routeGeomCache = new Map();
  const ROUTE_CACHE_MAX = 200;

  function q6(x){ return Math.round(x * 1e6); }
  function epKey(a,b){ return `${q6(a[0])},${q6(a[1])}|${q6(b[0])},${q6(b[1])}`; }

  const edgeAttrById = new Map();
  let shelterNameByNodeID = {};

  let catalog = null;
  const ageCache = new Map();
  const sliceCache = new Map();

  // ---------- Layers ----------
  const routeSource = new ol.source.Vector();
  const routeLayer = new ol.layer.Vector({
    source: routeSource,
    style: (feature) => {
      const t = feature.get("routeType");
      const s = ROUTE_STYLE[t] || {color:"rgba(0,0,0,0.8)", width:6};
      return new ol.style.Style({
        stroke: new ol.style.Stroke({ color: s.color, width: s.width })
      });
    }
  });

  const riskSource = new ol.source.Vector();
  const riskLayer = new ol.layer.Vector({
    source: riskSource,
    style: (feature) => {
      const rtype = feature.get("riskType");
      const dashed = !!feature.get("dashed");
      const color = RISK_COLOR[rtype] || "rgba(0,0,0,0.25)";
      return new ol.style.Style({
        stroke: new ol.style.Stroke({
          color,
          width: dashed ? 7 : 7,
          lineDash: dashed ? DASH_FINE : null,
          lineCap: "butt"
        })
      });
    }
  });

  const highlightSource = new ol.source.Vector();
  const highlightLayer = new ol.layer.Vector({
    source: highlightSource,
    style: (feature) => {
      const rtype = feature.get("riskType");
      const base = RISK_COLOR[rtype] || "rgba(0,0,0,0.35)";
      const color = base.replace(/rgba\(([^)]+),\s*0\.\d+\)/, "rgba($1,0.90)");
      return new ol.style.Style({
        stroke: new ol.style.Stroke({ color, width: 10, lineCap: "round" })
      });
    }
  });

  const pointSource = new ol.source.Vector();
  const pointLayer = new ol.layer.Vector({
    source: pointSource,
    style: (feature) => {
      const kind = feature.get("kind");
      const label = feature.get("label") || "";
      let fill = "rgba(255,255,255,0.9)";
      let stroke = "rgba(0,0,0,0.9)";
      let radius = 7;
      if (kind === "click") { fill = "rgba(0,0,0,0.9)"; stroke = "rgba(255,255,255,0.9)"; radius = 6; }
      return new ol.style.Style({
        image: new ol.style.Circle({
          radius,
          fill: new ol.style.Fill({ color: fill }),
          stroke: new ol.style.Stroke({ color: stroke, width: 2 })
        }),
        text: new ol.style.Text({
          text: label,
          font: "bold 12px sans-serif",
          fill: new ol.style.Fill({ color: kind === "click" ? "rgba(255,255,255,1)" : "rgba(0,0,0,1)" }),
          stroke: new ol.style.Stroke({ color: "rgba(255,255,255,0.9)", width: 3 }),
          offsetY: -15
        })
      });
    }
  });

  function ageDirName(age){
    const a = Number(age);
    return `age_${String(a).padStart(2, "0")}`;
  }

  // ---------- Map ----------
  const map = new ol.Map({
    target: "map",
    layers: [
      new ol.layer.Tile({ source: new ol.source.OSM() }),
      routeLayer,
      riskLayer,
      highlightLayer,
      pointLayer
    ],
    view: new ol.View({
      center: ol.proj.fromLonLat([136.1, 35.3]),
      zoom: 11
    })
  });
  
  addCoverageLayer(map);

  // disable DoubleClickZoom
  (function disableDoubleClickZoom(){
    const DCZ = ol?.interaction?.DoubleClickZoom;
    if (!DCZ) return;
    const rm = [];
    map.getInteractions().forEach((it) => { try { if (it instanceof DCZ) rm.push(it); } catch(_){} });
    rm.forEach((it)=>map.removeInteraction(it));
  })();

  // ---------- Popup overlay ----------
  const popupOverlay = new ol.Overlay({
    element: popupEl,
    autoPan: false,
    stopEvent: true,
    offset: [0, -12],
    positioning: "bottom-center"
  });
  map.addOverlay(popupOverlay);

  function hidePopup(){
    popupOverlay.setPosition(undefined);
    popupEl.style.display = "none";
    highlightSource.clear();
  }
  popupCloseBtn.addEventListener("click", hidePopup);

  // ---------- Utils ----------
  const sleep = (ms) => new Promise(r => setTimeout(r, ms));

  async function fetchText(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`fetch failed: ${url} (${r.status})`);
    return await r.text();
  }
  async function fetchJSON(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error(`fetch failed: ${url} (${r.status})`);
    return await r.json();
  }
  
  // ---- Coverage (data-absent) polygon layer ----
  function addCoverageLayer(map){
    const src = new ol.source.Vector({
      url: "./coverage_diff.geojson",
      format: new ol.format.GeoJSON(),
    });
  
    const layer = new ol.layer.Vector({
      source: src,
      style: new ol.style.Style({
        fill: new ol.style.Fill({ color: "rgba(120,120,120,0.25)" }),
        stroke: new ol.style.Stroke({ color: "rgba(80,80,80,0.9)", width: 2 }),
      }),
    });
  
    // 背面に置く（道路より下、ベース地図より上）
    layer.setZIndex(1);
  
    // 読み込み失敗が分かるように（任意）
    src.on("error", () => {
      console.warn("coverage_diff.geojson failed to load");
    });
  
    map.addLayer(layer);
    return layer;
  }

  function shelterName(nodeID){
    const o = shelterNameByNodeID?.[String(nodeID)] ?? shelterNameByNodeID?.[nodeID];
    if (!o) return "";
    if (typeof o === "string") return o;
    if (typeof o === "object") {
      if (typeof o.name === "string") return o.name;
      if (Array.isArray(o.names)) return o.names.join(" / ");
      try { return JSON.stringify(o); } catch(_) { return String(o); }
    }
    return String(o);
  }

  function formatMinutes(sec){
    if (!Number.isFinite(sec)) return "到達不能";
    return `${(sec/60).toFixed(1)} 分`;
  }

  function sameSeq(a, b){
    if (!a || !b) return false;
    if (a.length !== b.length) return false;
    for (let i=0;i<a.length;i++) if (a[i] !== b[i]) return false;
    return true;
  }

  function dist2(a,b){
    const dx=a[0]-b[0], dy=a[1]-b[1];
    return dx*dx+dy*dy;
  }
  function samePoint(a,b,tol){ return Math.abs(a[0]-b[0])<=tol && Math.abs(a[1]-b[1])<=tol; }

  // ---------- nearest node grid ----------
  function buildGrid(){
    let minLon=Infinity, maxLon=-Infinity, minLat=Infinity, maxLat=-Infinity;
    for (let i=0;i<nNodes;i++){
      const lo = lonArr[i], la = latArr[i];
      if (lo<minLon) minLon=lo;
      if (lo>maxLon) maxLon=lo;
      if (la<minLat) minLat=la;
      if (la>maxLat) maxLat=la;
    }
    gridMinLon=minLon; gridMinLat=minLat;
    gridCell = 0.01;
    grid = new Map();
    for (let i=0;i<nNodes;i++){
      const ix = Math.floor((lonArr[i]-gridMinLon)/gridCell);
      const iy = Math.floor((latArr[i]-gridMinLat)/gridCell);
      const key = ix + "," + iy;
      let arr = grid.get(key);
      if (!arr){ arr=[]; grid.set(key, arr); }
      arr.push(i);
    }
  }

  function nearestVid(lon, lat){
    const ix0 = Math.floor((lon-gridMinLon)/gridCell);
    const iy0 = Math.floor((lat-gridMinLat)/gridCell);
    let best = -1;
    let bestD = Infinity;
    for (let r=0; r<=8; r++){
      let foundAny = false;
      for (let dx=-r; dx<=r; dx++){
        for (let dy=-r; dy<=r; dy++){
          if (Math.max(Math.abs(dx), Math.abs(dy)) !== r) continue;
          const key = (ix0+dx) + "," + (iy0+dy);
          const arr = grid.get(key);
          if (!arr) continue;
          foundAny = true;
          for (const vid of arr){
            const d = (lonArr[vid]-lon)*(lonArr[vid]-lon) + (latArr[vid]-lat)*(latArr[vid]-lat);
            if (d < bestD){ bestD = d; best = vid; }
          }
        }
      }
      if (foundAny && best !== -1) return best;
    }
    return best;
  }

  // ---------- Load nodes ----------
  async function loadNodesCSV(){
    setStateLine("データ読み込み中…");
    const txt = await fetchText("./nodes_wgs84.csv");
    const lines = txt.split("\n");
    const header = lines[0].trim().split(",");
    const idxLon = header.indexOf("lon");
    const idxLat = header.indexOf("lat");
    const idxNodeID = header.indexOf("nodeID");
    const idxMuni = header.indexOf("muniCode");
    const idxIsShelter = header.indexOf("is_shelter");
    if (idxLon<0 || idxLat<0 || idxNodeID<0) throw new Error("nodes_wgs84.csv must have nodeID, lon, lat");

    const est = lines.length - 2;
    lonArr = new Float64Array(est);
    latArr = new Float64Array(est);
    nodeIdArr = new Int32Array(est);
    muniArr = new Int32Array(est);
    isShelterArr = new Uint8Array(est);

    let k=0;
    for (let i=1;i<lines.length;i++){
      const line = lines[i];
      if (!line) continue;
      const cols = line.split(",");
      const lo = Number(cols[idxLon]);
      const la = Number(cols[idxLat]);
      const nid = Number(cols[idxNodeID]);
      if (!Number.isFinite(lo) || !Number.isFinite(la) || !Number.isFinite(nid)) continue;

      lonArr[k]=lo; latArr[k]=la;
      nodeIdArr[k]=nid|0;

      const mc = (idxMuni>=0) ? Number(cols[idxMuni]) : -1;
      muniArr[k]=Number.isFinite(mc) ? (mc|0) : -1;

      const sh = (idxIsShelter>=0) ? Number(cols[idxIsShelter]) : 0;
      isShelterArr[k]=(Number.isFinite(sh) && sh===1) ? 1 : 0;

      nodeID2Vid.set(nodeIdArr[k], k);
      k++;

      if (k % 50000 === 0){ await sleep(0); }
    }
    nNodes = k;
    buildGrid();
  }

  // ---------- Load edge attrs ----------
  async function loadEdgeAttrs(){
    setStateLine("データ読み込み中…");
    const txt = await fetchText("./edge_attrs_by_edgeid.csv");
    const lines = txt.split("\n");
    const header = lines[0].trim().split(",");
    const idx = (name)=>header.indexOf(name);

    const iEdgeID = idx("edgeID");
    const iCount = idx("count");
    const iFloodPct = idx("flood_ratio_pct");

    const iRfallY = idx("Rfall_young_pct");
    const iRfallO = idx("Rfall_old_pct");

    const iBase = idx("rf_base_pct");
    const iFence = idx("rf_fence_pct");
    const iSlope = idx("rf_slope_pct");
    const iWidth = idx("rf_width_pct");

    if (iEdgeID<0) throw new Error("edge_attrs_by_edgeid.csv missing edgeID");

    for (let i=1;i<lines.length;i++){
      const line = lines[i];
      if (!line) continue;
      const c = line.split(",");
      const eid = Number(c[iEdgeID]);
      if (!Number.isFinite(eid)) continue;

      edgeAttrById.set(eid|0, {
        count: (iCount>=0) ? Number(c[iCount]) : 0,
        flood_ratio_pct: (iFloodPct>=0) ? Number(c[iFloodPct]) : NaN,
        Rfall_young_pct: (iRfallY>=0) ? Number(c[iRfallY]) : 0,
        Rfall_old_pct: (iRfallO>=0) ? Number(c[iRfallO]) : 0,
        rf_base_pct: (iBase>=0) ? Number(c[iBase]) : 0,
        rf_fence_pct: (iFence>=0) ? Number(c[iFence]) : 0,
        rf_slope_pct: (iSlope>=0) ? Number(c[iSlope]) : 0,
        rf_width_pct: (iWidth>=0) ? Number(c[iWidth]) : 0,
      });
    }
  }

  async function loadShelterNames(){
    setStateLine("データ読み込み中…");
    shelterNameByNodeID = await fetchJSON("./shelter_name_by_nodeID.json");
  }

  // ---------- Load edges geometry ----------
  function pushEdgeSegment(edgeID, coords){
    if (!coords || coords.length < 2) return;
    let arr = edgeSegsById.get(edgeID);
    if (!arr){ arr=[]; edgeSegsById.set(edgeID, arr); }
    arr.push(coords);

    const a = coords[0];
    const b = coords[coords.length-1];
    let mp = edgePartIndex.get(edgeID);
    if (!mp){ mp = new Map(); edgePartIndex.set(edgeID, mp); }
    mp.set(epKey(a,b), {coords, rev:false});
    mp.set(epKey(b,a), {coords, rev:true});
  }

  async function loadEdgesFGB(){
    setStateLine("データ読み込み中…");
    const fg = globalThis.flatgeobuf;
    if (!fg) throw new Error("flatgeobuf not loaded");

    const bboxAll = { minX: 135.764476, minY: 35.174088, maxX: 136.179544, maxY: 35.582073 };
    edgeSegsById.clear();

    let feats = 0;

    if (fg.geojson?.deserialize) {
      const resp = await fetch("./edges_min.fgb");
      if (!resp.ok) throw new Error(`fetch failed: edges_min.fgb (${resp.status})`);
      const buf = await resp.arrayBuffer();

      for await (const f of fg.geojson.deserialize(buf)) {
        feats++;
        if (feats === 1) console.log("First FGB feature:", f);

        const props = f.properties || {};
        const edgeID = props.edgeID ?? props.edgeId ?? props.id;
        if (edgeID == null) continue;

        const g = f.geometry;
        if (!g) continue;

        if (g.type === "LineString") pushEdgeSegment(String(edgeID), g.coordinates);
        else if (g.type === "MultiLineString") for (const part of g.coordinates) pushEdgeSegment(String(edgeID), part);

        if (feats % 50000 === 0) { await sleep(0); }
      }
    }
    else if (typeof fg.deserialize === "function") {
      const iter = fg.deserialize("./edges_min.fgb", bboxAll);
      if (!iter || typeof iter[Symbol.asyncIterator] !== "function") {
        throw new Error("flatgeobuf API mismatch (deserialize is not async iterable)");
      }
      for await (const f of iter) {
        feats++;
        if (feats === 1) console.log("First FGB feature:", f);

        const props = f.properties || {};
        const edgeID = props.edgeID ?? props.edgeId ?? props.id;
        if (edgeID == null) continue;

        const g = f.geometry;
        if (!g) continue;

        if (g.type === "LineString") pushEdgeSegment(String(edgeID), g.coordinates);
        else if (g.type === "MultiLineString") for (const part of g.coordinates) pushEdgeSegment(String(edgeID), part);

        if (feats % 50000 === 0) { await sleep(0); }
      }
    } else {
      throw new Error("No supported flatgeobuf API found");
    }
  }

  async function loadEdgesAuto(){
    try {
      await loadEdgesFGB();
    } catch(e){
      console.error("FGB load failed:", e);
      edgeSegsById.clear();
      setStateLine("エラー：道路形状（FGB）の読み込みに失敗しました。");
      // GeoJSONへフォールバックしない（404を出さない）
    }
  }

  // ---------- shapes.json + slice loader ----------
  function bytesPer(dtype){
    if (dtype==="float32") return 4;
    if (dtype==="int32") return 4;
    throw new Error("unsupported dtype: "+dtype);
  }
  function makeTyped(dtype, buffer){
    if (dtype==="float32") return new Float32Array(buffer);
    if (dtype==="int32") return new Int32Array(buffer);
    throw new Error("unsupported dtype: "+dtype);
  }
  async function fetchArraySlice(url, dtype, offsetBytes, lengthBytes){
    const headers = { "Range": `bytes=${offsetBytes}-${offsetBytes + lengthBytes - 1}` };
    let r = await fetch(url, { headers, cache:"force-cache" });
    if (r.status === 206){
      const ab = await r.arrayBuffer();
      return makeTyped(dtype, ab);
    }
    const abAll = await r.arrayBuffer();
    return makeTyped(dtype, abAll.slice(offsetBytes, offsetBytes+lengthBytes));
  }

  function getMeta(shapes, name){
    const dtypes = shapes.dtypes || {};
    const shapesMap = shapes.shapes || {};
    const files = shapes.files || {};
    const dtype = dtypes[name];
    const shape = shapesMap[name];
    const file = files[name];
    return {dtype, shape, file};
  }

  async function loadShapesForAge(age){
    if (ageCache.has(age)) return ageCache.get(age);
    const dir = ageDirName(age);
    const shapesUrl = `./${dir}/shapes.json`;
    const shapes = await fetchJSON(shapesUrl);

    let thresholds=null;
    if (Array.isArray(shapes.thresholds)) thresholds = shapes.thresholds.map(Number);
    if (!thresholds){
      const m = getMeta(shapes,"thresholds");
      if (m.file && m.dtype){
        const ab = await (await fetch(`${dir}/${m.file}`, {cache:"no-store"})).arrayBuffer();
        thresholds = Array.from(makeTyped(m.dtype, ab)).map(Number);
      }
    }
    if (!thresholds) throw new Error("thresholds not found.");

    let nn = shapes.n_nodes || null;
    if (!nn){
      const m = getMeta(shapes, "dist_global_psafe");
      if (m.shape && m.shape.length>=2) nn = Number(m.shape[m.shape.length-1]);
    }
    if (!nn) nn = nNodes;

    const info = {age, dir, shapes, thresholds, n_nodes: nn, superVid: nn};
    ageCache.set(age, info);
    return info;
  }

  function pickThrIdx(thresholds, thr){
    let bestI=0, bestD=Infinity;
    for (let i=0;i<thresholds.length;i++){
      const d = Math.abs(thresholds[i]-thr);
      if (d<bestD){ bestD=d; bestI=i; }
    }
    return bestI;
  }

  async function getSlice(ageInfo, name, thrIdx){
    const {dir, shapes, n_nodes} = ageInfo;
    const m = getMeta(shapes, name);
    if (!m.file || !m.dtype) throw new Error(`missing meta: ${name}`);

    const is2D = String(name).includes("psafe");
    const thr = is2D ? (thrIdx ?? 0) : 0;

    const key = `${dir}/${name}/thr${thr}`;
    if (sliceCache.has(key)) return sliceCache.get(key);

    const bpe = bytesPer(m.dtype);
    const rowBytes = n_nodes * bpe;
    const offset = is2D ? (thr * rowBytes) : 0;

    const url = `${dir}/${m.file}`;
    const arr = await fetchArraySlice(url, m.dtype, offset, rowBytes);

    sliceCache.set(key, arr);
    return arr;
  }

  // ---------- Route reconstruction ----------
  function reconstruct(predVid, predEdgeId, startVid, superVid, maxSteps=500000){
    const edgeSeq = [];
    const vidSeq = [startVid];
    let cur = startVid;
    for (let step=0; step<maxSteps; step++){
      const p = predVid[cur];
      if (p === -1) break;
      if (p === superVid) break;
      if (p < 0 || p >= superVid) break;
      edgeSeq.push(predEdgeId[cur]);
      vidSeq.push(p);
      cur = p;
    }
    return {vidSeq, edgeSeq};
  }

  function pickPartByEndpoints(edgeID, curPt, nextPt){
    const parts = edgeSegsById.get(edgeID);
    if (!parts || parts.length===0) return null;

    const mp = edgePartIndex.get(edgeID);
    if (mp){
      const ent = mp.get(epKey(curPt, nextPt));
      if (ent && ent.coords){
        const base = ent.rev ? ent.coords.slice().reverse() : ent.coords.slice();
        base[0] = curPt;
        base[base.length-1] = nextPt;
        return base;
      }
    }

    let best=null, bestScore=Infinity, rev=false;
    for (const part of parts){
      if (!part || part.length<2) continue;
      const a=part[0], b=part[part.length-1];
      const s1 = dist2(a,curPt) + dist2(b,nextPt);
      const s2 = dist2(b,curPt) + dist2(a,nextPt);
      if (s1<bestScore){ bestScore=s1; best=part; rev=false; }
      if (s2<bestScore){ bestScore=s2; best=part; rev=true; }
    }
    if (!best) return null;
    const coords = rev ? best.slice().reverse() : best.slice();
    coords[0]=curPt;
    coords[coords.length-1]=nextPt;
    return coords;
  }

  function buildRoute(edgeSeq, vidSeq){
    const lines=[];
    let curLine=[];
    const stepParts=[];

    const flush=()=>{ if (curLine.length>=2) lines.push(curLine); curLine=[]; };

    for (let i=0;i<edgeSeq.length;i++){
      const eid = Number(edgeSeq[i])|0;
      const vCur = vidSeq[i];
      const vNext = vidSeq[i+1];
      if (vNext===undefined) break;
      const curPt=[lonArr[vCur], latArr[vCur]];
      const nextPt=[lonArr[vNext], latArr[vNext]];

      let seg = pickPartByEndpoints(eid, curPt, nextPt);
      if (!seg) seg = [curPt, nextPt];

      stepParts.push({ edgeID: eid, coords: seg });

      if (curLine.length===0){
        curLine = seg.slice();
      } else {
        const last = curLine[curLine.length-1];
        if (samePoint(last, seg[0], TOL_JOIN)){
          for (let k=1;k<seg.length;k++) curLine.push(seg[k]);
        } else {
          flush();
          curLine = seg.slice();
        }
      }
    }
    flush();

    if (lines.length===0) return {geom:null, stepParts};

    const geom4326 = (lines.length===1) ? new ol.geom.LineString(lines[0]) : new ol.geom.MultiLineString(lines);
    const geom3857 = geom4326.transform("EPSG:4326","EPSG:3857");
    return {geom: geom3857, stepParts};
  }

  function addPointLonLat(lon, lat, kind, label=""){
    const f = new ol.Feature({ geometry: new ol.geom.Point(ol.proj.fromLonLat([lon,lat])) });
    f.set("kind", kind);
    f.set("label", label);
    pointSource.addFeature(f);
  }

  function addRoute(routeType, edgeSeq, vidSeq){
    const r = buildRoute(edgeSeq, vidSeq);
    if (!r.geom) return {ok:false, stepParts: r.stepParts};

    const f = new ol.Feature({ geometry: r.geom });
    f.set("routeType", routeType);
    routeSource.addFeature(f);
    return {ok:true, stepParts: r.stepParts};
  }

  function addDestMarker(rootNodeID, label){
    const vid = nodeID2Vid.get(rootNodeID|0);
    if (vid===undefined) return;
    addPointLonLat(lonArr[vid], latArr[vid], "dest", label);
  }

  function fitToAll(){
    const ex = ol.extent.createEmpty();
    for (const src of [routeSource, riskSource, pointSource]){
      src.forEachFeature((f)=>ol.extent.extend(ex, f.getGeometry().getExtent()));
    }
    if (!ol.extent.isEmpty(ex)) map.getView().fit(ex, {padding:[60,60,60,60], duration:150, maxZoom: 16});
  }

  // ---------- Risk overlay ----------
  function edgeRiskClass(attr, isOld){
    const count = Number(attr?.count ?? 0);
    const hasFlood = count > 0;
    const fallPct = isOld ? Number(attr?.Rfall_old_pct ?? 0) : Number(attr?.Rfall_young_pct ?? 0);
    const hasFall = fallPct > 0;
    if (hasFlood && hasFall) return "BOTH";
    if (hasFlood) return "FLOOD";
    if (hasFall) return "FALL";
    return null;
  }

  function addRiskFromStepParts(stepParts, dashed, isOld){
    let accType=null;
    let accCoords=null;
    let accAttr=null;

    const flush = () => {
      if (!accType || !accCoords || accCoords.length<2) { accType=null; accCoords=null; accAttr=null; return; }
      const geom = new ol.geom.LineString(accCoords).transform("EPSG:4326","EPSG:3857");
      const f = new ol.Feature({ geometry: geom });
      f.set("kind","risk");
      f.set("riskType", accType);
      f.set("dashed", dashed);

      const floodCount = Number(accAttr?.count ?? 0);
      const floodPct = Number.isFinite(Number(accAttr?.flood_ratio_pct))
        ? Number(accAttr?.flood_ratio_pct)
        : (floodCount/24.0*100.0);

      const fallPct = isOld ? Number(accAttr?.Rfall_old_pct ?? 0) : Number(accAttr?.Rfall_young_pct ?? 0);

      f.set("floodCount", floodCount);
      f.set("floodPct", floodPct);
      f.set("fallPct", fallPct);

      f.set("rf_width_pct", Number(accAttr?.rf_width_pct ?? 0));
      f.set("rf_base_pct", Number(accAttr?.rf_base_pct ?? 0));
      f.set("rf_slope_pct", Number(accAttr?.rf_slope_pct ?? 0));
      f.set("rf_fence_pct", Number(accAttr?.rf_fence_pct ?? 0));

      riskSource.addFeature(f);

      accType=null; accCoords=null; accAttr=null;
    };

    for (const sp of stepParts){
      const eid = sp.edgeID|0;
      const attr = edgeAttrById.get(eid);
      if (!attr) { flush(); continue; }

      const cls = edgeRiskClass(attr, isOld);
      if (!cls) { flush(); continue; }

      const coords = sp.coords;
      if (!coords || coords.length<2) { flush(); continue; }

      if (accType === cls){
        if (accCoords && samePoint(accCoords[accCoords.length-1], coords[0], TOL_JOIN)){
          for (let k=1;k<coords.length;k++) accCoords.push(coords[k]);
        } else {
          flush();
          accType = cls;
          accCoords = coords.slice();
          accAttr = attr;
        }
      } else {
        flush();
        accType = cls;
        accCoords = coords.slice();
        accAttr = attr;
      }
    }
    flush();
  }

  function buildRiskMessage(feature){
    const rtype = feature.get("riskType");
    const lines = [];

    const c = Number(feature.get("floodCount") ?? 0);
    const p = Number(feature.get("floodPct") ?? 0);
    if (rtype==="FLOOD" || rtype==="BOTH"){
      if (c>0) lines.push(`浸水の危険性: ${c.toFixed(0)}/24 (${p.toFixed(1)}%)`);
    }

    const fallPct = Number(feature.get("fallPct") ?? 0);
    if ((rtype==="FALL" || rtype==="BOTH") && fallPct>0){
      lines.push("転落の危険性");

      const w = Number(feature.get("rf_width_pct") ?? 0);
      const b = Number(feature.get("rf_base_pct") ?? 0);
      const s = Number(feature.get("rf_slope_pct") ?? 0);
      const f = Number(feature.get("rf_fence_pct") ?? 0);

      if (w>0) lines.push("・道路幅が狭く、水路との距離を十分に確保できない可能性があります");
      if (b>0) lines.push("・水路・河川に近接しており、転落するリスクが存在する可能性が高いです");
      if (s>0) lines.push("・道路に傾斜があり、歩行安定性を低減させる可能性があります");
      if (f>0) lines.push("・転落防止の防護柵の有無に注意してください");
    }

    if (lines.length===0) lines.push("リスク情報はありません。");
    return lines.join("\n");
  }

  map.on("singleclick", (evt) => {
    let picked=null;
    map.forEachFeatureAtPixel(evt.pixel, (feature) => {
      if (feature && feature.get("kind")==="risk"){ picked=feature; return true; }
      return false;
    });

    if (!picked){
      hidePopup();
      return;
    }

    highlightSource.clear();
    const hf = new ol.Feature({ geometry: picked.getGeometry().clone() });
    hf.set("riskType", picked.get("riskType"));
    highlightSource.addFeature(hf);

    const rtype = picked.get("riskType");
    popupTitleEl.textContent =
      (rtype==="BOTH") ? "浸水 + 転落の危険性" :
      (rtype==="FLOOD") ? "浸水の危険性" :
      (rtype==="FALL") ? "転落の危険性" : "リスク情報";

    popupContentEl.innerHTML = `<pre style="margin:0; white-space:pre-wrap;">${buildRiskMessage(picked)}</pre>`;

    popupOverlay.setPosition(evt.coordinate);
    popupEl.style.display="block";
  });

  // ---------- UI ----------
  function clearAll(){
    routeSource.clear();
    riskSource.clear();
    pointSource.clear();
    highlightSource.clear();
    hidePopup();
    lastPick = null;
    resultEl.textContent = "クリアしました。地図をダブルクリックしてください。";
    setStatusReady();
  }
  clearBtn.addEventListener("click", clearAll);

  thrRange.addEventListener("input", ()=> thrLabel.textContent = Number(thrRange.value).toFixed(1));

  const optComposite = document.getElementById("optComposite");
  const optRfallOnly = document.getElementById("optRfallOnly");

  function ensureExclusive(changed){
    if (!optComposite || !optRfallOnly) return;
    if (changed === "composite") {
      optComposite.checked = true;
      optRfallOnly.checked = false;
    } else {
      optComposite.checked = false;
      optRfallOnly.checked = true;
    }
  }

  async function rerunIfPicked(){
    if (!lastPick) return;
    await runFromPick(
      lastPick.lon, lastPick.lat, lastPick.v0,
      lastPick.startIsShelterNode, lastPick.startShelterNm
    );
  }

  if (optComposite && optRfallOnly){
    optComposite.addEventListener("change", async ()=>{
      if (!optComposite.checked){ optComposite.checked = true; return; }
      ensureExclusive("composite");
      await rerunIfPicked();
    });

    optRfallOnly.addEventListener("change", async ()=>{
      if (!optRfallOnly.checked){ optRfallOnly.checked = true; return; }
      ensureExclusive("rfall");
      await rerunIfPicked();
    });
  }

  thrRange.addEventListener("change", async ()=>{
    if (!lastPick) return;
    await runFromPick(lastPick.lon, lastPick.lat, lastPick.v0, lastPick.startIsShelterNode, lastPick.startShelterNm);
  });

  ageSelect.addEventListener("change", async ()=>{
    if (!lastPick) return;
    await runFromPick(lastPick.lon, lastPick.lat, lastPick.v0, lastPick.startIsShelterNode, lastPick.startShelterNm);
  });

  // ---------- rerun support ----------
  let lastPick = null;
  let runToken = 0;

  async function runFromPick(lon, lat, v0, startIsShelterNode, startShelterNm){
    const myToken = ++runToken;
    hidePopup();

    try{
      if (v0 < 0) return;

      const age = Number(ageSelect.value);
      const thr = Number(thrRange.value);
      const isOld = age >= 65;

      // 状態表示（現在条件）
      const modeLabel = (optRfallOnly && optRfallOnly.checked) ? "転落のみ" : "複合";
      setCondLine(age, thr);

      routeSource.clear(); riskSource.clear(); pointSource.clear(); highlightSource.clear();

      addPointLonLat(lon, lat, "click", "");
      addPointLonLat(lonArr[v0], latArr[v0], "start", "S");

      const ageInfo = await loadShapesForAge(age);
      if (myToken !== runToken) return;

      const thrIdx = pickThrIdx(ageInfo.thresholds, thr);

      async function runOne(modeName, thrIdxUse){
        const cacheKey = `${age}|${modeName}|${thrIdxUse}|${v0}`;
        if (routeResultCache.has(cacheKey)) return routeResultCache.get(cacheKey);

        const dict = {
          "global_psafe": ["dist_global_psafe","root_global_psafe","pred_vid_global_psafe","pred_edgeid_global_psafe"],
          "muni_psafe":   ["dist_muni_psafe","root_muni_psafe","pred_vid_muni_psafe","pred_edgeid_muni_psafe"],
          "global_rfall": ["dist_global_rfall","root_global_rfall","pred_vid_global_rfall","pred_edgeid_global_rfall"],
          "muni_rfall":   ["dist_muni_rfall","root_muni_rfall","pred_vid_muni_rfall","pred_edgeid_muni_rfall"],
        }[modeName];

        const [dN,rN,pvN,peN] = dict;

        const [distArr, rootArr, predV, predE] = await Promise.all([
          getSlice(ageInfo, dN, thrIdxUse),
          getSlice(ageInfo, rN, thrIdxUse),
          getSlice(ageInfo, pvN, thrIdxUse),
          getSlice(ageInfo, peN, thrIdxUse),
        ]);

        if (myToken !== runToken) return {ok:false, dist:Infinity, root:-1, edgeSeq:null, vidSeq:null};

        const dist = distArr[v0];
        const root = rootArr[v0];
        if (!Number.isFinite(dist) || root===-1){
          return {ok:false, dist:Infinity, root:-1, edgeSeq:null, vidSeq:null};
        }
        const {vidSeq, edgeSeq} = reconstruct(predV, predE, v0, ageInfo.superVid);
        const out = {ok:true, dist:Number(dist), root:Number(root), edgeSeq, vidSeq};
        routeResultCache.set(cacheKey, out);
        if (routeResultCache.size > ROUTE_CACHE_MAX){
          const firstKey = routeResultCache.keys().next().value;
          routeResultCache.delete(firstKey);
        }
        return out;
      }

      const lines = [];
      lines.push(`年齢：${getAgeLabel()} / 期待安全度：${thr.toFixed(1)}`);
      if (startIsShelterNode){
        lines.push("※避難所そのもの（または避難所に非常に近い地点）を指定しています。");
        if (startShelterNm) lines.push(`  指定された避難所：${startShelterNm}`);
        lines.push("  避難時間が0分となる場合があります。");
      }

      const showRoute = (routeType, out, destLabel, dashedOverride=null) => {
        const r = addRoute(routeType, out.edgeSeq, out.vidSeq);
        addDestMarker(out.root, destLabel);
        const dashed = (dashedOverride !== null) ? dashedOverride
          : (routeType==="A" || routeType==="B" || routeType==="A0" || routeType==="B0");
        addRiskFromStepParts(r.stepParts, dashed, isOld);
      };

      const rfallOnlyMode = (optRfallOnly && optRfallOnly.checked);

      // --- 転落のみモード ---
      if (rfallOnlyMode){
        lines.push("表示モード：転落リスク回避（浸水は考慮しません）");

        const outCA = await runOne("muni_rfall", thrIdx);
        const outCB = await runOne("global_rfall", thrIdx);

        if (outCA.ok || outCB.ok){
          if (outCA.ok && outCB.ok && sameSeq(outCA.edgeSeq, outCB.edgeSeq)){
            lines.push("CA と CB は同一経路 → CA のみ表示");
            showRoute("CA", outCA, "CA", false);
            lines.push(`CA（同自治体）: ${formatMinutes(outCA.dist)} / 避難所：${shelterName(outCA.root) || "（名称不明）"}`);
          } else {
            if (outCA.ok){
              showRoute("CA", outCA, "CA", false);
              lines.push(`CA（同自治体）: ${formatMinutes(outCA.dist)} / 避難所：${shelterName(outCA.root) || "（名称不明）"}`);
            } else lines.push("CA（同自治体）: 到達不能");

            if (outCB.ok){
              showRoute("CB", outCB, "CB", false);
              lines.push(`CB（境界なし）: ${formatMinutes(outCB.dist)} / 避難所：${shelterName(outCB.root) || "（名称不明）"}`);
            } else lines.push("CB（境界なし）: 到達不能");
          }

          lines.push("道路（危険区間）をクリックしてリスクをご確認ください。");
          resultEl.textContent = lines.join("\n");
          fitToAll();
          setCondLine(age, thr);
          return;
        }

        // fallback to A0/B0
        lines.push("転落回避（CA/CB）が到達不能 → A0/B0（期待安全度=0.0）を表示");
        const thrIdx0 = pickThrIdx(ageInfo.thresholds, 0.0);
        const outA0 = await runOne("muni_psafe", thrIdx0);
        const outB0 = await runOne("global_psafe", thrIdx0);

        if (outA0.ok || outB0.ok){
          if (outA0.ok && outB0.ok && sameSeq(outA0.edgeSeq, outB0.edgeSeq)){
            lines.push("A0 と B0 は同一経路 → A0 のみ表示");
            showRoute("A0", outA0, "A0", true);
            lines.push(`A0（同自治体）: ${formatMinutes(outA0.dist)} / 避難所：${shelterName(outA0.root) || "（名称不明）"}`);
          } else {
            if (outA0.ok){
              showRoute("A0", outA0, "A0", true);
              lines.push(`A0（同自治体）: ${formatMinutes(outA0.dist)} / 避難所：${shelterName(outA0.root) || "（名称不明）"}`);
            } else lines.push("A0（同自治体）: 到達不能");

            if (outB0.ok){
              showRoute("B0", outB0, "B0", true);
              lines.push(`B0（境界なし）: ${formatMinutes(outB0.dist)} / 避難所：${shelterName(outB0.root) || "（名称不明）"}`);
            } else lines.push("B0（境界なし）: 到達不能");
          }
          lines.push("道路（危険区間）をクリックしてリスクをご確認ください。");
          resultEl.textContent = lines.join("\n");
          fitToAll();
          setCondLine(age, thr);
          return;
        }

        resultEl.textContent = "到達可能な経路が見つかりませんでした。";
        setStateLine("準備完了：地図をダブルクリックしてください");
        return;
      }

      // --- 複合（A/B → CA/CB → A0/B0） ---
      const outA = await runOne("muni_psafe", thrIdx);
      const outB = await runOne("global_psafe", thrIdx);
      if (myToken !== runToken) return;

      if (outA.ok || outB.ok){
        if (outA.ok && outB.ok && sameSeq(outA.edgeSeq, outB.edgeSeq)){
          lines.push("A と B は同一経路 → A（推奨）のみ表示");
          showRoute("A", outA, "A", true);
          lines.push(`A（同自治体）: ${formatMinutes(outA.dist)} / 避難所：${shelterName(outA.root) || "（名称不明）"}`);
        } else {
          if (outA.ok){
            showRoute("A", outA, "A", true);
            lines.push(`A（同自治体）: ${formatMinutes(outA.dist)} / 避難所：${shelterName(outA.root) || "（名称不明）"}`);
          } else lines.push("A（同自治体）: 到達不能");

          if (outB.ok){
            showRoute("B", outB, "B", true);
            lines.push(`B（境界なし）: ${formatMinutes(outB.dist)} / 避難所：${shelterName(outB.root) || "（名称不明）"}`);
          } else lines.push("B（境界なし）: 到達不能");
        }
        lines.push("道路（危険区間）をクリックしてリスクをご確認ください。");
        resultEl.textContent = lines.join("\n");
        fitToAll();
        setCondLine(age, thr);
        return;
      }

      lines.push("A/B が到達不能 → CA/CB（転落回避）を表示");
      const outCA = await runOne("muni_rfall", thrIdx);
      const outCB = await runOne("global_rfall", thrIdx);

      if (outCA.ok || outCB.ok){
        if (outCA.ok && outCB.ok && sameSeq(outCA.edgeSeq, outCB.edgeSeq)){
          lines.push("CA と CB は同一経路 → CA のみ表示");
          showRoute("CA", outCA, "CA", false);
          lines.push(`CA（同自治体）: ${formatMinutes(outCA.dist)} / 避難所：${shelterName(outCA.root) || "（名称不明）"}`);
        } else {
          if (outCA.ok){
            showRoute("CA", outCA, "CA", false);
            lines.push(`CA（同自治体）: ${formatMinutes(outCA.dist)} / 避難所：${shelterName(outCA.root) || "（名称不明）"}`);
          } else lines.push("CA（同自治体）: 到達不能");

          if (outCB.ok){
            showRoute("CB", outCB, "CB", false);
            lines.push(`CB（境界なし）: ${formatMinutes(outCB.dist)} / 避難所：${shelterName(outCB.root) || "（名称不明）"}`);
          } else lines.push("CB（境界なし）: 到達不能");
        }
        lines.push("道路（危険区間）をクリックしてリスクをご確認ください。");
        resultEl.textContent = lines.join("\n");
        fitToAll();
        setCondLine(age, thr);
        return;
      }

      lines.push("CA/CB も到達不能 → A0/B0（期待安全度=0.0）を表示");
      const thrIdx0 = pickThrIdx(ageInfo.thresholds, 0.0);
      const outA0 = await runOne("muni_psafe", thrIdx0);
      const outB0 = await runOne("global_psafe", thrIdx0);

      if (outA0.ok || outB0.ok){
        if (outA0.ok && outB0.ok && sameSeq(outA0.edgeSeq, outB0.edgeSeq)){
          lines.push("A0 と B0 は同一経路 → A0 のみ表示");
          showRoute("A0", outA0, "A0", true);
          lines.push(`A0（同自治体）: ${formatMinutes(outA0.dist)} / 避難所：${shelterName(outA0.root) || "（名称不明）"}`);
        } else {
          if (outA0.ok){
            showRoute("A0", outA0, "A0", true);
            lines.push(`A0（同自治体）: ${formatMinutes(outA0.dist)} / 避難所：${shelterName(outA0.root) || "（名称不明）"}`);
          } else lines.push("A0（同自治体）: 到達不能");

          if (outB0.ok){
            showRoute("B0", outB0, "B0", true);
            lines.push(`B0（境界なし）: ${formatMinutes(outB0.dist)} / 避難所：${shelterName(outB0.root) || "（名称不明）"}`);
          } else lines.push("B0（境界なし）: 到達不能");
        }
        lines.push("道路（危険区間）をクリックしてリスクをご確認ください。");
        resultEl.textContent = lines.join("\n");
        fitToAll();
        setCondLine(age, thr);
        return;
      }

      resultEl.textContent = "到達可能な経路が見つかりませんでした。";
      setStateLine("準備完了：地図をダブルクリックしてください");

    } catch(err){
      console.error(err);
      setStateLine("エラー：" + (err?.message || String(err)));
    }
  }

  // ---------- dblclick ----------
  map.on("dblclick", async (evt) => {
    evt.preventDefault();
    hidePopup();

    try{
      const [lon,lat] = ol.proj.toLonLat(evt.coordinate);
      const v0 = nearestVid(lon,lat);
      if (v0<0) return;

      const startIsShelterNode = (isShelterArr && isShelterArr[v0] === 1);
      const startNodeID = (nodeIdArr ? nodeIdArr[v0] : null);
      const startShelterNm = (startIsShelterNode && startNodeID != null) ? shelterName(startNodeID) : null;

      lastPick = { lon, lat, v0, startIsShelterNode, startShelterNm };
      await runFromPick(lon, lat, v0, startIsShelterNode, startShelterNm);

    } catch(err){
      console.error(err);
      setStateLine("エラー：" + (err?.message || String(err)));
    }
  });

  // ---------- Init ----------
  async function init(){
    thrLabel.textContent = Number(thrRange.value).toFixed(1);

    setStatusLoading();
    catalog = await fetchJSON("./catalog.json");

    // 年齢UIはレンジ表示（内部的には代表年齢フォルダを使う）
    // value = 実際に読む age_XX（代表年齢）
    const ageBuckets = [
      { label: "6～10歳",   value: 10 },
      { label: "11～60歳",  value: 40 },
      { label: "61～65歳",  value: 65 },
      { label: "66～70歳",  value: 70 },
	  { label: "71～75歳",  value: 75 },
      { label: "76～80歳",  value: 80 },
      { label: "81～85歳",  value: 85 },
      { label: "86～90歳",  value: 90 },
    ];

    ageSelect.innerHTML = "";
    for (const b of ageBuckets){
      const opt = document.createElement("option");
      opt.value = String(b.value);      // ← ここが内部の代表年齢
      opt.textContent = b.label;        // ← ここが画面表示
      ageSelect.appendChild(opt);
    }

    // デフォルトは「11～60歳」
    ageSelect.value = "40";


    // 初期条件ライン
    //setCondLine(Number(ageSelect.value), Number(thrRange.value), (optRfallOnly && optRfallOnly.checked) ? "転落のみ" : "複合");

    await loadShelterNames();
    await loadNodesCSV();
    await loadEdgeAttrs();
    await loadEdgesAuto();

    setStatusReady();
    // 内部情報はUIに出さない（必要ならConsoleへ）
    console.log("Ready edges=", edgeSegsById.size);
  }

  init().catch(err=>{
    console.error(err);
    setStateLine("エラー：" + (err?.message || String(err)));
  });

})();
</script>
</body>
</html>
